<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WangWangZhou Blog</title>
  
  <subtitle>WangWangZhou Blog</subtitle>
  <link href="https://fpga.vip/atom.xml" rel="self"/>
  
  <link href="https://fpga.vip/"/>
  <updated>2021-08-12T02:23:14.961Z</updated>
  <id>https://fpga.vip/</id>
  
  <author>
    <name>WangWangZhou</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>413.等差数列划分</title>
    <link href="https://fpga.vip/2021/08/11/413-%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86/"/>
    <id>https://fpga.vip/2021/08/11/413-%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86/</id>
    <published>2021-08-11T08:01:33.000Z</published>
    <updated>2021-08-12T02:23:14.961Z</updated>
    
    <content type="html"><![CDATA[<h1>题目</h1><p>如果一个数列 <strong>至少有三个元素</strong> ，并且任意两个相邻元素之差相同，则称该数列为等差数列。</p><ul><li>例如，<code>[1,3,5,7,9]</code>、<code>[7,7,7,7]</code> 和 <code>[3,-1,-5,-9]</code> 都是等差数列。</li></ul><p>给你一个整数数组 <code>nums</code> ，返回数组 <code>nums</code> 中所有为等差数组的 <strong>子数组</strong> 个数。</p><p><strong>子数组</strong> 是数组中的一个连续序列。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：nums = [1,2,3,4]<br>输出：3<br>解释：nums 中有三个子等差数组：[1, 2, 3]、[2, 3, 4] 和 [1,2,3,4] 自身。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：nums = [1]<br>输出：0<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5000</code></li><li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li></ul><h1>思路与代码</h1><h2 id="方法一：双指针法">方法一：双指针法</h2><p>有几个关键点我们必须要清晰，等差数列，子数组。</p><ul><li>等差数列是指从第二项起，每一项与它的前一项的差等于<strong>同一个常数</strong>的一种数列</li><li>子数组是数组中的一个连续序列，连续，长度至少为3</li><li>一个子数组如果分为前后两部分，前面不是等差数列，那么后面部分就不用判断了</li></ul><p>因此，对于每个起始位置，我们只需要向后进行一遍扫描，不断累加，直到不再构成等差数列为止，此时，已经没有必要再向后扫描了。</p><img src="https://xinqianpingtaib2btest.oss-cn-shenzhen.aliyuncs.com/xinqianpingtaib2btest/blogimg/2020/20210811223521.png" style="zoom:67%;" /><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numberOfArithmeticSlices</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">2</span>; i++) &#123;<br>        <span class="hljs-type">int</span> d = nums[i + <span class="hljs-number">1</span>] - nums[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; len - <span class="hljs-number">1</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j + <span class="hljs-number">1</span>] - nums[j] == d)<br>                res++; <br>            <span class="hljs-keyword">else</span> <br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^{2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><h2 id="方法二：双指针法优化">方法二：双指针法优化</h2><p>很明显，上面的双指针法，我们已经知道，以<code>4</code>为开头的<code>[4,6,8,10]</code>是等差子数组，再计算以<code>6</code>为开头的<code>[6,8,10]</code>是否为等差数组，重复计算。那我们如何知道长度为<code>L</code>的等差数列对结果的贡献呢?</p><p>我们不妨枚举一下。</p><p><img src="https://xinqianpingtaib2btest.oss-cn-shenzhen.aliyuncs.com/xinqianpingtaib2btest/blogimg/2020/20210811223753.png" alt=""></p><ul><li>长度为 3 的连续的等差数列，有 4 个</li><li>长度为 4 的连续的等差数列，有 3 个</li><li>长度为 5 的连续的等差数列，有 2 个</li><li>长度为 6 的连续的等差数列，有 1 个</li></ul><p>所以，长度为<code>L</code>的等差数列对结果的贡献为，</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>L</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>L</mi><mo>−</mo><mn>3</mn><mo stretchy="false">)</mo><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mn>2</mn><mo>+</mo><mn>1</mn><mo>=</mo><mfrac><mrow><mrow><mo fence="true">(</mo><mi>L</mi><mo>−</mo><mn>2</mn><mo>+</mo><mn>1</mn><mo fence="true">)</mo></mrow><mrow><mo fence="true">(</mo><mi>L</mi><mo>−</mo><mn>2</mn><mo fence="true">)</mo></mrow></mrow><mn>2</mn></mfrac><mo>=</mo><mfrac><mrow><mrow><mo fence="true">(</mo><mi>L</mi><mo>−</mo><mn>1</mn><mo fence="true">)</mo></mrow><mrow><mo fence="true">(</mo><mi>L</mi><mo>−</mo><mn>2</mn><mo fence="true">)</mo></mrow></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">(L-2)+(L-3)+...+2+1=\frac{\left(L-2+1\right)\left(L-2\right)}{2}=\frac{\left(L-1\right)\left(L-2\right)}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.113em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.113em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numberOfArithmeticSlices</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-type">int</span> len = nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">3</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 初始化</span><br><span class="hljs-type">int</span> preDiff = nums[<span class="hljs-number">1</span>] - nums[<span class="hljs-number">0</span>];<br><span class="hljs-comment">// 当前得到的等差数列的长度，有「差」必有两个元素，因此初始化的时候 L = 2</span><br><span class="hljs-type">int</span> L = <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 从下标 2 开始比较「当前的差」与「上一轮的差」是否相等</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; len; i++) &#123;<br><span class="hljs-type">int</span> diff = nums[i] - nums[i - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">if</span> (diff == preDiff) &#123;<br>L++;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 加入结果，然后重置 L 和 preDiff</span><br>res += (L - <span class="hljs-number">1</span>) * (L - <span class="hljs-number">2</span>) / <span class="hljs-number">2</span>;<br>L = <span class="hljs-number">2</span>;<br>preDiff = diff;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 最后还要再计算一下结果</span><br>res += (L - <span class="hljs-number">1</span>) * (L - <span class="hljs-number">2</span>) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个答案得出来的分数有点低，主要在于我们每一步都计算一次等差数列。其实，我们可以用一个while循环来跳到不相等的位置再计算子数组对结果的贡献。</p><p><img src="https://xinqianpingtaib2btest.oss-cn-shenzhen.aliyuncs.com/xinqianpingtaib2btest/blogimg/2020/20210812101453.png" alt=""></p><h3 id="补充1">补充1</h3><p>长度为<code>L</code>的连续子序列中，长度为<code>3</code>的连续等差数列的个数为<code>L-2</code>，可以从下面这张图看出来。</p><img src="https://xinqianpingtaib2btest.oss-cn-shenzhen.aliyuncs.com/xinqianpingtaib2btest/blogimg/2020/20210812090852.png" style="zoom: 67%;" /><ul><li>长度为 3 的连续的等差数列，结尾留2个位置，对结果的贡献为，<code>L-2</code></li><li>长度为 4 的连续的等差数列，结尾留3个位置，对结果的贡献为，<code>L-3</code></li><li>长度为 5 的连续的等差数列，结尾留4个位置，对结果的贡献为，<code>L-4</code></li><li>长度为 6 的连续的等差数列，结尾留5个位置，对结果的贡献为，<code>L-5</code></li></ul><h3 id="补充2">补充2</h3><p>等差数列的基本公式为，<code>和(S) = (首项 + 末项) x 项数 ÷ 2</code>。<code>项数(n) = (末项 - 首项) ÷公差+1</code></p><img src="https://xinqianpingtaib2btest.oss-cn-shenzhen.aliyuncs.com/xinqianpingtaib2btest/blogimg/2020/20210812094300.png" style="zoom:33%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;题目&lt;/h1&gt;
&lt;p&gt;如果一个数列 &lt;strong&gt;至少有三个元素&lt;/strong&gt; ，并且任意两个相邻元素之差相同，则称该数列为等差数列。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如，&lt;code&gt;[1,3,5,7,9]&lt;/code&gt;、&lt;code&gt;[7,7,7,7]&lt;/code&gt; 和</summary>
      
    
    
    
    
    <category term="leetcode" scheme="https://fpga.vip/tags/leetcode/"/>
    
    <category term="cpp" scheme="https://fpga.vip/tags/cpp/"/>
    
    <category term="java" scheme="https://fpga.vip/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>968. 监控二叉树</title>
    <link href="https://fpga.vip/2020/09/23/968-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://fpga.vip/2020/09/23/968-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-09-23T00:37:00.000Z</published>
    <updated>2020-10-23T01:23:20.848Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="https://leetcode-cn.com/problems/binary-tree-cameras/">968. 监控二叉树</a></h1><p>给定一个二叉树，我们在树的节点上安装摄像头。</p><p>节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象。</strong></p><p>计算监控树的所有节点所需的最小摄像头数量。</p><p><strong>示例 1：</strong></p><p><img src="https://xinqianpingtaib2btest.oss-cn-shenzhen.aliyuncs.com/xinqianpingtaib2btest/blogimg/2020/bst_cameras_01.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：[0,0,null,0,0]<br>输出：1<br>解释：如图所示，一台摄像头足以监控所有节点。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://xinqianpingtaib2btest.oss-cn-shenzhen.aliyuncs.com/xinqianpingtaib2btest/blogimg/2020/bst_cameras_02.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入：[0,0,null,0,null,0,null,null,0]<br>输出：2<br>解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>给定树的节点数的范围是 [1, 1000]。</li><li>每个节点的值都是 0。</li></ol><h1>java代码</h1><p>这是一道hard难度的题目。我们要从底向上进行推导，因为尽量让叶子节点的父节点安装摄像头，这样摄像头的数量才是最少的。<br>如何从低向上推导呢？<br>采用后序遍历也就是左右中的顺序，这样就可以从下到上进行推导了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//NO_CAMERA表示的是子节点没有相机，当前节点也没放相机</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NO_CAMERA</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//HAS_CAMERA表示当前节点有一个相机</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">HAS_CAMERA</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//NO_NEEDED表示当前节点没有相机，但他的子节点有一个相机，把它给</span><br>    <span class="hljs-comment">//覆盖了，所以它不需要了。或者他是一个空的节点也是不需要相机的</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NO_NEEDED</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br>    <span class="hljs-comment">//全局的，统计有多少相机</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCameraCover</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">//边界条件判断</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//如果最后返回的是NO_CAMERA，表示root节点的子节点也没有相机，</span><br>        <span class="hljs-comment">//所以root节点要添加一个相机</span><br>        <span class="hljs-keyword">if</span> (dfs(root) == NO_CAMERA)<br>            res++;<br>        <span class="hljs-comment">//返回结果</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-comment">//如果是空的，就不需要相机了</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> NO_NEEDED;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> dfs(root.left);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> dfs(root.right);<br>        <span class="hljs-comment">//如果左右子节点有一个是NO_CAMERA，表示的是子节点既没相机，也没相机覆盖它，</span><br>        <span class="hljs-comment">//所以当前节点需要有一个相机</span><br>        <span class="hljs-keyword">if</span> (left == NO_CAMERA || right == NO_CAMERA) &#123;<br>            <span class="hljs-comment">//在当前节点放一个相机，统计相机的个数</span><br>            res++;<br>            <span class="hljs-keyword">return</span> HAS_CAMERA;<br>        &#125;<br>        <span class="hljs-comment">//如果左右子节点只要有一个有相机，那么当前节点就不需要相机了，否则返回一个没有相机的标记</span><br>        <span class="hljs-keyword">return</span> (left == HAS_CAMERA || right == HAS_CAMERA) ? NO_NEEDED : NO_CAMERA;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="cpp代码">cpp代码</h2><p>状态</p><ul><li>0：该节点无覆盖，(说明，左孩子有覆盖，右孩子有覆盖，那么此时中间节点应该就是无覆盖的状态了。)</li><li>1：本节点有摄像头</li><li>2：本节点有覆盖</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> result;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur)</span> </span>&#123;<br><br>        <span class="hljs-comment">// 空节点，该节点有覆盖</span><br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br><br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">traversal</span>(cur-&gt;left);    <span class="hljs-comment">// 左</span><br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">traversal</span>(cur-&gt;right);  <span class="hljs-comment">// 右</span><br>        <br>        <span class="hljs-comment">//先考虑左右节点，再考虑中间节点，所以采用后序遍历</span><br><br>        <span class="hljs-comment">// 情况1 - - - - - - 左右节点都有覆盖</span><br>        <span class="hljs-comment">// 左右节点都有覆盖</span><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">2</span> &amp;&amp; right == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 情况2 - - - - - - - - - - - -- - - - 左右节点至少有一个无覆盖的情况</span><br>        <span class="hljs-comment">// left == 0 &amp;&amp; right == 0 左右节点无覆盖</span><br>        <span class="hljs-comment">// left == 1 &amp;&amp; right == 0 左节点有摄像头，右节点无覆盖</span><br>        <span class="hljs-comment">// left == 0 &amp;&amp; right == 1 左节点有无覆盖，右节点摄像头</span><br>        <span class="hljs-comment">// left == 0 &amp;&amp; right == 2 左节点无覆盖，右节点覆盖</span><br>        <span class="hljs-comment">// left == 2 &amp;&amp; right == 0 左节点覆盖，右节点无覆盖</span><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span> || right == <span class="hljs-number">0</span>) &#123;<br>            result++;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 情况3 - - - - - - - - - - - - - - - - - - - - 左右节点至少有一个有摄像头</span><br>        <span class="hljs-comment">// left == 1 &amp;&amp; right == 2 左节点有摄像头，右节点有覆盖</span><br>        <span class="hljs-comment">// left == 2 &amp;&amp; right == 1 左节点有覆盖，右节点有摄像头</span><br>        <span class="hljs-comment">// left == 1 &amp;&amp; right == 1 左右节点都有摄像头</span><br>        <span class="hljs-comment">// 其他情况前段代码均已覆盖</span><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">1</span> || right == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br><br>        <span class="hljs-comment">// 以上代码我没有使用else，主要是为了把各个分支条件展现出来，这样代码有助于读者理解</span><br>        <span class="hljs-comment">// 这个 return -1 逻辑不会走到这里。</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCameraCover</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        result = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 情况4</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">traversal</span>(root) == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// root 无覆盖</span><br>            result++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1>参考资料</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-cameras/solution/jian-kong-er-cha-shu-by-leetcode-solution/">监控二叉树</a></p><p><a href="https://leetcode-cn.com/problems/binary-tree-cameras/solution/968-jian-kong-er-cha-shu-di-gui-shang-de-zhuang-ta/">968. 监控二叉树:【递归上的状态转移】详解</a></p><p><a href="https://leetcode-cn.com/problems/binary-tree-cameras/solution/cong-xia-wang-shang-ji-suan-ji-bai-liao-100de-yong/">从下往上计算，击败了100%的用户</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-tree-cameras/&quot;&gt;968. 监控二叉树&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;给定一个二叉树，我们在树的节点上安装摄像头。&lt;/p&gt;
&lt;p&gt;节点上的每个摄影头都可以监视&lt;stro</summary>
      
    
    
    
    <category term="leetcode" scheme="https://fpga.vip/categories/leetcode/"/>
    
    
    <category term="java" scheme="https://fpga.vip/tags/java/"/>
    
    <category term="贪心" scheme="https://fpga.vip/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="后序遍历" scheme="https://fpga.vip/tags/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>hexo资料</title>
    <link href="https://fpga.vip/2020/09/21/hexo%E8%B5%84%E6%96%99-1/"/>
    <id>https://fpga.vip/2020/09/21/hexo%E8%B5%84%E6%96%99-1/</id>
    <published>2020-09-21T03:04:00.000Z</published>
    <updated>2020-10-23T01:23:20.862Z</updated>
    
    <content type="html"><![CDATA[<p>hexo文档<br><a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p><p>hexo next主题<br><a href="https://theme-next.iissnan.com/getting-started.html">https://theme-next.iissnan.com/getting-started.html</a></p><p>hexo常用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">npm install hexo -g   //安装  <br>npm update hexo -g   //升级 <br>hexo version        //查看hexo的版本<br>hexo init nodejs-hexo   //创建nodejs-hexo 名字的本地文件<br>hexo init nodejs-hexo    //创建博客<br>hexo init blog          //初始化，生成文件夹为blog<br>cd blog               //进入blog文件夹<br>npm install            //安装依赖库<br>hexo generate           //生成一套静态网页<br>hexo server         //运行测试,浏览器打开地址，http://localhost:4000/<br>hexo deploy         //进行部署<br><br>hexo new &quot;new article&quot;  //新建文章‘new article’<br>hexo new page &quot;about&quot;  //新建页面 ‘about’<br><br>hexo n &quot;我的博客&quot;` == `hexo new` &quot;我的博客&quot;    //新建文章<br>hexo g == hexo generate        //生成`<br>hexo s == hexo server          //启动服务预览<br>hexo d == hexo deploy          //部署<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;hexo文档&lt;br&gt;
&lt;a href=&quot;https://hexo.io/zh-cn/docs/&quot;&gt;https://hexo.io/zh-cn/docs/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;hexo next主题&lt;br&gt;
&lt;a href=&quot;https://theme-next.iissn</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>LeetCode课程表</title>
    <link href="https://fpga.vip/2019/12/23/LeetCode%E8%AF%BE%E7%A8%8B%E8%A1%A8/"/>
    <id>https://fpga.vip/2019/12/23/LeetCode%E8%AF%BE%E7%A8%8B%E8%A1%A8/</id>
    <published>2019-12-23T09:03:00.000Z</published>
    <updated>2020-10-23T01:23:20.854Z</updated>
    
    <content type="html"><![CDATA[<h1>题目</h1><p>现在你总共有 n 门课需要选，记为 <code>0</code> 到 <code>n-1</code>。</p><p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: <code>[0,1]</code></p><p>给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？</p><p>示例 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入: 2, [[1,0]] <br>输出: true<br>解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。<br></code></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入: 2, [[1,0],[0,1]]<br>输出: false<br>解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。<br></code></pre></td></tr></table></figure><p>说明:</p><p>输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。<br>你可以假定输入的先决条件中没有重复的边。<br>提示:</p><p>这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。<br>通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。<br>拓扑排序也可以通过 BFS 完成。</p><h1>代码</h1><h2 id="方法1：广度优先遍历">方法1：广度优先遍历</h2><p>我们使用一个队列来进行广度优先搜索。初始时，所有入度为 0 的节点都被放入队列中，它们就是可以作为拓扑排序最前面的节点，并且它们之间的相对顺序是无关紧要的。</p><p>在广度优先搜索的每一步中，我们取出队首的节点 u：</p><p>我们将 u 放入答案中；</p><p>我们移除 u 的所有出边，也就是将 u 的所有相邻节点的入度减少 11。如果某个相邻节点 v 的入度变为 0，那么我们就将 v 放入队列中。</p><p>在广度优先搜索的过程结束后。如果答案中包含了这 n 个节点，那么我们就找到了一种拓扑排序，否则说明图中存在环，也就不存在拓扑排序了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canFinish</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, <span class="hljs-type">int</span> prerequisites)</span> &#123;<br><br>        <span class="hljs-type">int</span>[] indegrees = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[numCourses];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] cp : prerequisites) indegrees[cp[<span class="hljs-number">0</span>]]++;<span class="hljs-comment">//入度增加</span><br><br>        LinkedList&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numCourses; i++)&#123;<br><br>            <span class="hljs-keyword">if</span>(indegrees[i] == <span class="hljs-number">0</span>) queue.addLast(i);<br><br>        &#125;<br><br>        <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br><br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> queue.removeFirst();<br><br>            numCourses--;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] req : prerequisites) &#123;<span class="hljs-comment">//循环二维数组</span><br><br>                <span class="hljs-keyword">if</span>(req[<span class="hljs-number">1</span>] != pre) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//判断是不是依赖这一门课，如果不是，就跳过</span><br>                <span class="hljs-comment">//如果是这门课,入席数组减减</span><br><br>                <span class="hljs-keyword">if</span>(--indegrees[req[<span class="hljs-number">0</span>]] == <span class="hljs-number">0</span>) queue.add(req[<span class="hljs-number">0</span>]);<br><br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> numCourses == <span class="hljs-number">0</span>;<br><br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="方法2：深度优先遍历">方法2：深度优先遍历</h2><p>对于图中的任意一个节点，它在搜索的过程中有三种状态，即：</p><ul><li><p>「未搜索」：我们还没有搜索到这个节点；</p></li><li><p>「搜索中」：我们搜索过这个节点，但还没有回溯到该节点，即该节点还没有入栈，还有相邻的节点没有搜索完成）；</p></li><li><p>「已完成」：我们搜索过并且回溯过这个节点，即该节点已经入栈，并且所有该节点的相邻节点都出现在栈的更底部的位置，满足拓扑排序的要求。</p></li></ul><p>通过上述的三种状态，我们就可以给出使用深度优先搜索得到拓扑排序的算法流程，在每一轮的搜索搜索开始时，我们任取一个「未搜索」的节点开始进行深度优先搜索。</p><p>我们将当前搜索的节点 u 标记为「搜索中」，遍历该节点的每一个相邻节点 v：</p><ul><li><p>如果 v 为「未搜索」，那么我们开始搜索 v，待搜索完成回溯到 u；</p></li><li><p>如果 v 为「搜索中」，那么我们就找到了图中的一个环，因此是不存在拓扑排序的；</p></li><li><p>如果 v 为「已完成」，那么说明 v 已经在栈中了，而 u 还不在栈中，因此 u 无论何时入栈都不会影响到 (u,v) 之前的拓扑关系，以及不用进行任何操作。</p></li></ul><p>当 u 的所有相邻节点都为「已完成」时，我们将 u 放入栈中，并将其标记为「已完成」。</p><p>在整个深度优先搜索的过程结束后，如果我们没有找到图中的环，那么栈中存储这所有的 n 个节点，从栈顶到栈底的顺序即为一种拓扑排序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Solution &#123;<br>    List&lt;List&lt;Integer&gt;&gt; edges;<br>    int[] visited;<br>    boolean valid = true;<br><br>    public boolean canFinish(int numCourses, int[][] prerequisites) &#123;<br>        edges = new ArrayList&lt;List&lt;Integer&gt;&gt;();<br>        for (int i = 0; i &lt; numCourses; ++i) &#123;<br>            edges.add(new ArrayList&lt;Integer&gt;());<br>        &#125;<br>        visited = new int[numCourses];<br>        for (int[] info : prerequisites) &#123;<br>            edges.get(info[1]).add(info[0]);<br>        &#125;<br>        for (int i = 0; i &lt; numCourses &amp;&amp; valid; ++i) &#123;<br>            if (visited[i] == 0) &#123;<br>                dfs(i);<br>            &#125;<br>        &#125;<br>        return valid;<br>    &#125;<br><br>    public void dfs(int u) &#123;<br>        visited[u] = 1;<br>        for (int v: edges.get(u)) &#123;<br>            if (visited[v] == 0) &#123;<br>                dfs(v);<br>                if (!valid) &#123;<br>                    return;<br>                &#125;<br>            &#125; else if (visited[v] == 1) &#123;<br>                valid = false;<br>                return;<br>            &#125;<br>        &#125;<br>        visited[u] = 2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;题目&lt;/h1&gt;
&lt;p&gt;现在你总共有 n 门课需要选，记为 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;n-1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: &lt;code&gt;[</summary>
      
    
    
    
    
    <category term="leetcode" scheme="https://fpga.vip/tags/leetcode/"/>
    
    <category term="BFS" scheme="https://fpga.vip/tags/BFS/"/>
    
    <category term="DFS" scheme="https://fpga.vip/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>地下城游戏(dungeon-game)</title>
    <link href="https://fpga.vip/2019/12/10/%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F-dungeon-game/"/>
    <id>https://fpga.vip/2019/12/10/%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F-dungeon-game/</id>
    <published>2019-12-10T08:32:00.000Z</published>
    <updated>2020-10-23T01:23:20.864Z</updated>
    
    <content type="html"><![CDATA[<h1>题目</h1><p>一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p><p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p><p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。</p><p>为了尽快到达公主，骑士决定每次只向右或向下移动一步。</p><p>编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。</p><p>例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -&gt; 右 -&gt; 下 -&gt; 下，则骑士的初始健康点数至少为 7。</p><p>-2 (K)-33<br>-5-101<br>1030-5 §</p><p>说明:</p><p>骑士的健康点数没有上限。</p><p>任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。</p><h1>思路</h1><p>参考了评论中的答案，使用动态规划 核心思路是：每次只能往右边或者下面走，那么如果你知道了往右边走需要的最小生命代价和往下面需要的最小生命代价，那么你就知道了当前需要的最小代价 使用二维数组来保存最小生命代价，life[i][j]表示从i，j开始走到右下角的最小生命代价 从右下开始往上动态规划，初始话最小代价是1，如果当前不需要额外的生命代价的话，那么当前的最小生命代价就是1，如果需要额外的代价的话，那么最小生命代价就是额外需要的代价。 说的比较绕口，代码应该比较好理解，总的思路就是，如果后面不需要额外生命，那么你只需要保证能走到当前就可以了，如果后面需要额外代价，那么你需要保证能走到当前并且+后面的额外生命代价</p><h2 id="java代码">java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 求骑士走到右下角的最低生命值</span><br>    <span class="hljs-comment">// 只能右或者下</span><br>    <span class="hljs-comment">// DP</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateMinimumHP</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] dungeon)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> dungeon.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> dungeon[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] life = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[row][col]; <span class="hljs-comment">// life[i][j] 表示i,j的时候需要的最小生命值，肯定不能小于1</span><br>        <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-keyword">if</span>(dungeon[row - <span class="hljs-number">1</span>][col - <span class="hljs-number">1</span>] &lt; <span class="hljs-number">0</span>)&#123;<br>            life[row - <span class="hljs-number">1</span>][col - <span class="hljs-number">1</span>] = -dungeon[row - <span class="hljs-number">1</span>][col - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            life[row - <span class="hljs-number">1</span>][col - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 初始化最后一列</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> row - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">if</span>(life[i+<span class="hljs-number">1</span>][col-<span class="hljs-number">1</span>] == <span class="hljs-number">1</span>)&#123; <span class="hljs-comment">// 表示后面的可以自己满足</span><br>                life[i][col-<span class="hljs-number">1</span>] = Math.max(<span class="hljs-number">1</span>,-dungeon[i][col - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 后面的不可以满足</span><br>                life[i][col-<span class="hljs-number">1</span>] = Math.max(life[i+<span class="hljs-number">1</span>][col-<span class="hljs-number">1</span>] - dungeon[i][col - <span class="hljs-number">1</span>],<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 初始话最后一行</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> col - <span class="hljs-number">2</span>; j &gt;= <span class="hljs-number">0</span>; j --)&#123;<br>            <span class="hljs-keyword">if</span>(life[row - <span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] == <span class="hljs-number">1</span>)&#123;<br>                life[row-<span class="hljs-number">1</span>][j] = Math.max(<span class="hljs-number">1</span>,-dungeon[row-<span class="hljs-number">1</span>][j]+<span class="hljs-number">1</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                life[row-<span class="hljs-number">1</span>][j] = Math.max(life[row-<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]-dungeon[row-<span class="hljs-number">1</span>][j],<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> row - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> col - <span class="hljs-number">2</span>; j&gt;= <span class="hljs-number">0</span>; j--)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Math.min(life[i][j+<span class="hljs-number">1</span>],life[i+<span class="hljs-number">1</span>][j]);<br>                <span class="hljs-keyword">if</span>(min == <span class="hljs-number">1</span>)&#123; <span class="hljs-comment">// 后面可以满足</span><br>                    life[i][j] = Math.max(<span class="hljs-number">1</span>,-dungeon[i][j]+<span class="hljs-number">1</span>);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    life[i][j] = Math.max(<span class="hljs-number">1</span>,min-dungeon[i][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> life[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="python代码">python代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calculateMinimumHP</span>(<span class="hljs-params">self, dungeon</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type dungeon: List[List[int]]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        row, col = <span class="hljs-built_in">len</span>(dungeon), <span class="hljs-built_in">len</span>(dungeon[<span class="hljs-number">0</span>])<br>        mem = [[<span class="hljs-number">0</span>]*col <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(row)]<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(row-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(col-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> i == row-<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> j == col-<span class="hljs-number">1</span>:<br>                    mem[i][j] = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, -dungeon[i][j])<br>                <span class="hljs-keyword">elif</span> i == row-<span class="hljs-number">1</span>:<br>                    mem[i][j] = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, mem[i][j+<span class="hljs-number">1</span>] - dungeon[i][j])<br>                <span class="hljs-keyword">elif</span> j == col-<span class="hljs-number">1</span>:<br>                    mem[i][j] = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, mem[i+<span class="hljs-number">1</span>][j] - dungeon[i][j])<br>                <span class="hljs-keyword">else</span>:<br>                    mem[i][j] = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">min</span>(mem[i+<span class="hljs-number">1</span>][j], mem[i][j+<span class="hljs-number">1</span>]) - dungeon[i][j])<br>                <br>        <span class="hljs-keyword">return</span> mem[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;题目&lt;/h1&gt;
&lt;p&gt;一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。&lt;/p&gt;
&lt;p&gt;骑士的初始健康点数为一个正整数。如果他的健康点</summary>
      
    
    
    
    <category term="刷题" scheme="https://fpga.vip/categories/%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://fpga.vip/categories/%E5%88%B7%E9%A2%98/leetcode/"/>
    
    
    <category term="java" scheme="https://fpga.vip/tags/java/"/>
    
    <category term="动态规划" scheme="https://fpga.vip/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>最小路径和(minimum-path-sum)</title>
    <link href="https://fpga.vip/2019/12/09/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C-minimum-path-sum/"/>
    <id>https://fpga.vip/2019/12/09/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C-minimum-path-sum/</id>
    <published>2019-12-09T13:31:00.000Z</published>
    <updated>2022-12-06T08:49:38.473Z</updated>
    
    <content type="html"><![CDATA[<h1>题目</h1><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><p><strong>示例:</strong></p><p><strong>输入:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br>输出:  7<br>解释:  因为路径 1→3→1→1→1 的总和最小。<br></code></pre></td></tr></table></figure><h2 id="思路">思路</h2><h2 id="思路">思路</h2><ol><li><strong>状态定义</strong>：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">设dp[i][j]为走到当前位置的最小路径和<br></code></pre></td></tr></table></figure><ol><li><strong>递推公式</strong>：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">只能向下或向右走，意味着当前格子只能由上边或者左边走过来<br>dp[i][j] = Min(dp[i-1][j],dp[i][j-1]) + grid[i][j]<br></code></pre></td></tr></table></figure><ol><li><strong>初始化</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">第一行第n列和第一列第n行为均原数组值<br></code></pre></td></tr></table></figure><ol><li><strong>边界条件</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">格子有边界，因此当i==0 或j==0时，i-1和j-1会越界<br>i = 0，j != 0时,dp[i][j] = dp[i][j-1]+grid[i][j]<br>i !=0，j == 0时,dp[i][j] = dp[i-1][j]+grid[i][j]<br>i !=0 &amp;&amp; j != 0时,dp[i][j] = Min(dp[i-1][j],dp[i][j-1])+grid[i][j]<br>i == 0 &amp;&amp; j == 0时,dp[i][j]=grid[i][j]<br></code></pre></td></tr></table></figure><ol><li><strong>返回值</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">dp最后一个元素值<br></code></pre></td></tr></table></figure><h2 id="代码">代码</h2><p>cpp代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt; &gt;&amp; grid)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (grid.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> row = grid.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> column = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt; &gt; <br><span class="hljs-built_in">dp</span>(row, std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(column, <span class="hljs-number">0</span>));<br>    <br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; column; i++)&#123;<br>    dp[<span class="hljs-number">0</span>][i] = dp[<span class="hljs-number">0</span>][i<span class="hljs-number">-1</span>] + grid[<span class="hljs-number">0</span>][i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; row; i++)&#123;<br>    dp[i][<span class="hljs-number">0</span>] = dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] + grid[i][<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; column; j++)&#123;<br>    dp[i][j] = std::<span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>]) + grid[i][j];<br>    &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[row<span class="hljs-number">-1</span>][column<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> test[][<span class="hljs-number">3</span>] = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;&#125;;<br>std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt; &gt; grid;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)&#123;<br>grid.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++)&#123;<br>grid[i].<span class="hljs-built_in">push_back</span>(test[i][j]);<br>&#125;<br>&#125;<br>Solution solve;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, solve.<span class="hljs-built_in">minPathSum</span>(grid));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>java代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> minimum_path_sum;<br><br><span class="hljs-comment">//64.最小路径和</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>    <span class="hljs-comment">//定义dp数组</span><br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[grid.length][grid[<span class="hljs-number">0</span>].length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> grid.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                <span class="hljs-keyword">if</span>(i == grid.length - <span class="hljs-number">1</span> &amp;&amp; j != grid[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>)<span class="hljs-comment">//如果右边界,那么只能向左走</span><br>                    dp[i][j] = grid[i][j] +  dp[i][j + <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == grid[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span> &amp;&amp; i != grid.length - <span class="hljs-number">1</span>)<span class="hljs-comment">//如果下边界,那么只能向上走</span><br>                    dp[i][j] = grid[i][j] + dp[i + <span class="hljs-number">1</span>][j];<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j != grid[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span> &amp;&amp; i != grid.length - <span class="hljs-number">1</span>)<span class="hljs-comment">//如果不是边界的情况,则要进行判断最小路径和</span><br>                    dp[i][j] = grid[i][j] + Math.min(dp[i + <span class="hljs-number">1</span>][j], dp[i][j + <span class="hljs-number">1</span>]);<br>                <span class="hljs-keyword">else</span><br>                    dp[i][j] = grid[i][j];<span class="hljs-comment">//从这个元素开始走</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[][] grid = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">Solution</span> <span class="hljs-variable">solu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Solution</span>();<br>    System.out.println(solu.minPathSum(grid));<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;题目&lt;/h1&gt;
&lt;p&gt;给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。&lt;/p&gt;
&lt;p&gt;说明：每次只能向下或者向右移动一步。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入:</summary>
      
    
    
    
    
    <category term="java" scheme="https://fpga.vip/tags/java/"/>
    
    <category term="动态规划" scheme="https://fpga.vip/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>win10 安装docker</title>
    <link href="https://fpga.vip/2018/12/07/win10-%E5%AE%89%E8%A3%85docker/"/>
    <id>https://fpga.vip/2018/12/07/win10-%E5%AE%89%E8%A3%85docker/</id>
    <published>2018-12-07T10:49:05.000Z</published>
    <updated>2020-10-23T01:23:20.859Z</updated>
    
    <content type="html"><![CDATA[<h1>Docker介绍</h1><p>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。<br>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。<br>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p><h2 id="docker基本概念">Docker基本概念</h2><p>docker包含三个基本概念：<br>镜像（Image）<br>容器（Container）<br>仓库（Repository）<br>理解了这三个概念，就理解了docker的整个生命周期了！</p><h3 id="docker镜像">Docker镜像</h3><p>Docker镜像（Image）就是一个只读的模板。<br>Docker镜像可以用来创建Docker容器。</p><p>Docker镜像和Docker容器的关系，类似于java中class类与对象之间的关系。</p><p>Docker提供了一个很简单的机制来创建镜像或者更新已有的镜像，用户甚至可以直接从其他人那里下载一个已经做好的镜像来直接使用。</p><h3 id="容器">容器</h3><p>Docker利用容器（Container）来运行应用。<br>容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。</p><p>可以把容器看成是一个简易版的Linux环境（包括ROOT用户权限、进程空间、用户空间、网络等）和运行在其中的应用程序。</p><h3 id="registry">Registry</h3><p>Registry是集中存放镜像文件的场所。<br>仓库（Repository）是对于其中的镜像进行分类管理。</p><p>一个Registry中会有多个Repository。<br>一个Repository中会有多个不同tag的Image。</p><p>比如名称为centos的Repository仓库下，有tag为6或者7的Image镜像。</p><p>Registry分为公有（public）和私有（private）两种形式。<br>最大的公有Registry是Docker Hub，存放了数量庞大的镜像供用户下载使用。<br>国内的公开Registry包括USTC、网易云、DaoCloud、AliCloud等，可以供大陆用户更稳当快捷的访问。<br>用户可以在本地创建一个私有Registry。</p><p>用户创建了自己的镜像之后就可以使用push命令将它上传的公有Registry或者私有Registry中，这样下次在另一台机器上使用这个镜像的时候，只需要从Registry上pull下来运行就可以了。</p><h1>安装</h1><h2 id="docker官网下载">docker官网下载</h2><p>首先在docker网站上注册一个账户，然后下载。<br><a href="https://docs.docker.com/docker-for-windows/install/#download-docker-for-windows">Docker for windows下载地址</a></p><h2 id="国内下载地址">国内下载地址</h2><p>对于Windows 10以下的用户，推荐使用Docker Toolbox<br>Windows安装文件：<a href="http://mirrors.aliyun.com/docker-toolbox/windows/docker-toolbox/">http://mirrors.aliyun.com/docker-toolbox/windows/docker-toolbox/</a><br>对于Windows 10以上的用户 推荐使用Docker for Windows<br>Windows安装文件：<a href="http://mirrors.aliyun.com/docker-toolbox/windows/docker-for-windows/">http://mirrors.aliyun.com/docker-toolbox/windows/docker-for-windows/</a></p><h2 id="文档">文档</h2><p><a href="https://docs.docker.com/docker-for-windows/install/">安装文档英文版</a><br>建议读一下英文版 。</p><h2 id="开启hyper-v">开启Hyper-v</h2><p>安装需要开启Hyper-V，如果是win10家庭版的话，可以需要升级win10专业版。可到某宝购买专业版的key。</p><p><img  src="http://xinqianpingtaib2btest.oss-cn-shenzhen.aliyuncs.com/blogimg/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20181207185736.png"  ><span class="image-caption">CPU虚拟化</span></p><p>控制面板-程序-windows功能<br><img  src="http://xinqianpingtaib2btest.oss-cn-shenzhen.aliyuncs.com/blogimg/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20181207185832.png"  ><span class="image-caption">在这里插入图片描述</span></p><h2 id="安装过程">安装过程</h2><p>安装时会有360报黑客新建帐号登录提示，这个还不太清楚，建议点允许。<br><img  src="http://xinqianpingtaib2btest.oss-cn-shenzhen.aliyuncs.com/blogimg/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20181207191959.png"  ><span class="image-caption">360报docker黑客行为</span></p><p><img  src="http://xinqianpingtaib2btest.oss-cn-shenzhen.aliyuncs.com/blogimg/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20181207192221.png"  ><span class="image-caption">docker安装成功</span></p><p><img  src="http://xinqianpingtaib2btest.oss-cn-shenzhen.aliyuncs.com/blogimg/20181207222044.jpg"  ><span class="image-caption">在这里插入图片描述</span></p><h2 id="登录">登录</h2><p><img  src="http://xinqianpingtaib2btest.oss-cn-shenzhen.aliyuncs.com/blogimg/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20181207192335.png"  ><span class="image-caption">docker登录</span></p><h2 id="安装是否成功">安装是否成功</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">E:\&gt;docker --version<br>Docker version 18.09.0, build 4d60db4<br></code></pre></td></tr></table></figure><h1>Hello-world</h1><h2 id="拉取helloworld镜像">拉取helloWorld镜像</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">E:\&gt;docker pull hello-world<br>Using default tag: latest<br>Error response from daemon: <br>Get https://registry-1.docker.io/v2/library/hello-world/manifests/latest: <br>net/http: TLS handshake timeout<br></code></pre></td></tr></table></figure><p>发现下载不来</p><h2 id="配置镜像加速">配置镜像加速</h2><p>Docker可以配置的国内镜像有很多可供选择，比如说：阿里云，网易蜂巢，DaoCloud，Docker中国区官方镜像等，这些都是可以提供给大家随意选择的不错的镜像仓库。</p><p><a href="https://jingyan.baidu.com/article/f3e34a12c607f4f5eb653596.html">阿里云docker镜像加速</a><br><strong>建议不要加端口号</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&#123;<br>  &quot;registry-mirrors&quot;: [<br>    &quot;https://xxx.mirror.aliyuncs.com:443&quot;<br>  ],<br>  &quot;insecure-registries&quot;: [],<br>  &quot;debug&quot;: true,<br>  &quot;experimental&quot;: true<br>&#125;<br></code></pre></td></tr></table></figure><p>里面的xxx是的你阿里云镜像加速地址。<br>再次下载，下载成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">E:\&gt;docker pull hello-world<br>Using default tag: latest<br>latest: Pulling from library/hello-world<br>d1725b59e92d: Pull complete<br>Digest: sha256:0add3ace90ecb4adbf7777e9aacf1<br>Status: Downloaded newer image for hello-world:latest<br></code></pre></td></tr></table></figure><p>运行hello-world</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">E:\&gt;docker run hello-world<br>Hello from Docker!<br></code></pre></td></tr></table></figure><h1>docker 命令</h1><h2 id="docker镜像命令">docker镜像命令</h2><h3 id="查找镜像">查找镜像</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">E:\&gt;docker search centos<br>NAME     DESCRIPTION      STARS               OFFICIAL            AUTOMATED<br>centos          The official build of CentOS.              5020             [OK]<br></code></pre></td></tr></table></figure><h3 id="拉取镜像">拉取镜像</h3><p>拉取镜像也就是把镜像下载到本地</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">E:\&gt;docker pull centos<br>Using default tag: latest<br>latest: Pulling from library/centos<br>a02a49cb5d: Extracting [=========&gt;     ]  69.07MB/75.17MB<br></code></pre></td></tr></table></figure><h3 id="列出镜像">列出镜像</h3><p>列出本地镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">E:\&gt;docker images<br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>centos              latest              1e1148e4cc2c        38 hours ago        202MB<br>mysql               5.6                 a876cc5d29e4        3 weeks ago         256MB<br></code></pre></td></tr></table></figure><h2 id="docker容器">docker容器</h2><h3 id="启动容器">启动容器</h3><p>运行交互式的容器<br>这里的&quot;1e1148e4cc2c&quot;是上面docker  images列出来的镜像的 ID</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">E:\&gt;docker run -i -t 1e1148e4cc2c /bin/bash<br>[root@33bab162592 /]# ls<br>anaconda-post.log  bin  dev  etc  home  lib  lib64  media  mnt  <br>opt  proc  root  run  sbin  srv  sys  tmp  usr  var<br>[root@33bab162592 /]# cat /etc/centos-release<br>CentOS Linux release 7.6.1810 (Core)<br>[root@33bab162592 /]# exit<br>exit<br>E:\&gt;<br></code></pre></td></tr></table></figure><p>我们通过docker的两个参数 -i -t，让docker运行的容器实现&quot;对话&quot;的能力<br>各个参数解析：<br>-t:在新容器内指定一个伪终端或终端。<br>-i:允许你对容器内的标准输入 (STDIN) 进行交互。</p><p>以交互方式启动容器：docker run -it --name 容器名称 镜像 /bin/bash<br>以守护进程方式启动容器：docker run -d --name 容器名称 镜像</p><h3 id="停止容器">停止容器</h3><p>docker stop 容器名称或者容器ID</p><h3 id="重启容器">重启容器</h3><p>docker start 容器名称或者容器ID</p><h3 id="删除容器">删除容器</h3><p>删除指定容器：docker rm 容器名称或者容器ID</p><p>删除所有容器：docker rm ‘docker ps -a -q’</p><h3 id="查看容器">查看容器</h3><p>docker ps ：查看正在运行的容器<br>docker ps -a：查看历史运行过的容器<br>docker ps -l：查看最近运行过的容器</p><h1>Docker 应用</h1><h2 id="windows下载docker搭建mysql">windows下载docker搭建mysql</h2><p>下载mysql镜像 docker pull mysql，docker run运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">docker run -d --rm --name ecMysql <br>-v D:\docker\mysql:/var/lib/mysql <br>-v D:\docker\mysqlConf:/etc/mysql/conf.d <br>-e MYSQL_ROOT_PASSWORD=123456 <br>-p 3307:3306 mysql <br>--character-set-server=utf8mb4 <br>--collation-server=utf8mb4_unicode_ci<br></code></pre></td></tr></table></figure><p>添加：–character-set-server=utf8mb4 –collation-server=utf8mb4_unicode_ci 防止中文乱码<br>参数解释：<br>-d 后台运行<br>–rm windows下stop后自动rm在stop ps中的镜像，linux下次参数不能使用<br>–name 给镜像起别名<br>-v 本地目录:镜像目录<br>-e 给镜像设置环境变量 MYSQL_ROOT_PASSWORD=123456这句为设置密码为123456<br>-p 暴露端口 格式– 本地端口:镜像端口<br>docker run [参数] 镜像名</p><p>进入mysql</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>E:\&gt;docker ps -a<br>CONTAINER ID        IMAGE    COMMAND   CREATED             STATUS     PORTS  NAMES<br>a4df   mysql:5.6   &quot;do…&quot;   5 seconds ago    Up 3 seconds  0.0.0.0:3307-&gt;3306/tcp   ecMysql<br><br>E:\&gt;docker exec -it ecMysql /bin/bash<br>root@a4d15abc185:/# mysql -u root -P 3307 -p<br>Enter password:<br>Welcome to the MySQL monitor.  Commands end with ; or \g.<br>Your MySQL connection id is 3<br>Server version: 5.6.42 MySQL Community Server (GPL)<br><br>Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.<br><br>Oracle is a registered trademark of Oracle Corporation and/or its<br>affiliates. Other names may be trademarks of their respective<br>owners.<br><br>Type &#x27;help;&#x27; or &#x27;\h&#x27; for help. Type &#x27;\c&#x27; to clear the current input statement.<br><br>mysql&gt;<br></code></pre></td></tr></table></figure><p>设置一个用户，方便远程登录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">use mysql<br>select Host,User from user;<br>grant all on *.* to &#x27;ddff&#x27;@&#x27;%&#x27; identified by &#x27;ddgg2018&#x27;;<br></code></pre></td></tr></table></figure><p>添加远程访问账户<br>前面已经暴露端口，直接使用Navicat连接操作即可，当然你也可以用命令行 ，ip：127.0.0.1 用户名：ddff 密码：ddgg2018</p><h1>参考资料</h1><p><a href="http://www.runoob.com/docker/docker-tutorial.html">菜鸟教程 - docker教程</a></p><p><a href="https://blog.csdn.net/qq_26819733/article/details/79069981">window下搭建Docker的Mysql环境</a></p><p><a href="http://www.runoob.com/docker/docker-command-manual.html">docker 命令教程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Docker介绍&lt;/h1&gt;
&lt;p&gt;Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。&lt;br&gt;
Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟</summary>
      
    
    
    
    
  </entry>
  
</feed>
